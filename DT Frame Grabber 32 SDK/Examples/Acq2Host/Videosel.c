/*
        File:   Videosel.c

        Description:
                This file contains all the necessary functions for the Video
                Selection dialog box.  The following functions are in this file:

                VideoSelectProc() - dialog proc for Setup VideoSelection dialog

                InitComboBoxFromControlList() -
                                initializes the contents of a combo box with the values
                                from a "limits list" generated by a capability query of
                                the frame grabber driver

                InitCSyncSourceList() -
                                initializes the Compsite Sync Source list box for the video
                                select dialog

                SetCsyncInfo() -
                                sets the frame grabber's composite sync controls as indicated
                                by the user

                SetVarscanInfo() -
                                sets the frame grabber's variable scan flags as indicated
                                by the user

*/

/*=========================================================================++
||                                                                         ||
||      Copyright (C) 1996.   Data Translation, Inc., 100 Locke Drive,     ||
||      Marlborough Massachusetts 01752-1192.                              ||
||                                                                         ||
||      The information in this document is subject to change without      ||
||      notice and should not be construed as a commitment by Data         ||
||      Translation, Inc.  Data Translation, Inc. does not assume any      ||
||      responsibility for any errors that may appear in this document.    ||
||                                                                         ||
||      This document, or source code, is provided solely as an example    ||
||      of how to utilize Data Translation software libraries in a sample  ||
||      application.  Data Translation, Inc. does not assume any           ||
||      responsibility for the use or reliability of any portion of this   ||
||      document or the described software.                                ||
||                                                                         ||
||      General permission to copy or modify, but not for profit, is       ||
||      hereby granted,  provided that the above copyright notice is       ||
||      included and reference made to the fact that reproduction          ||
||      privileges were granted by Data Translation, Inc.                  ||
||                                                                         ||
||      Data Translation cannot assume any responsibility for the use,     ||
||      or misuse, of any portion of this software for other than its      ||
||      intended diagnostic purpose in calibrating and testing Data        ||
||      Translation manufactured image processing boards and software.     ||
||                                                                         ||
++=========================================================================*/


/* Let's use strict type checking in this program */
#define STRICT

#include "acq2hst.h"                    /* specific to the acq2hst example */


static LPCSTR lpcszCsyncExternal = "Use external sync";
static LPCSTR lpcszCsyncCurrent = "Use current source";
static LPCSTR lpcszCsyncSpecific = "Use Input ";


/**************************************************************************/
/**************************************************************************/

/*      Function:       VideoSelectProc

        Description:
                This function is the dialog procedure for the dialog box used to
                select/define the type of video being fed into the frame grabber.
                This information is used by the frame grabber to determine how
                to interpret various portions of the video signal (e.g., sync).

        Initialization:
                This dialog box should be invoked using DialogBox.

        Input Arguments:
                HWND hDlg               dialog handle
                UINT message            message
                WPARAM wParam           16-bit message-specific data
                LPARAM lParam           32-bit message-specific data

        Output Arguments:
                None

        EndDialog Return:  BOOL
                TRUE if everything went okay, FALSE otherwise.

        Returns:  BOOL
                Except in response to WM_INITDIALOG, TRUE is returned if the
                dialog proc processes the message, FALSE if it does not.  For
                WM_INITDIALOG, FALSE is returned if the dialog proc calls
                SetFocus to set the input focus to a specific control.  If
                not, TRUE should be returned to indicate that the input focus
                should be given to the first control in the dialog that can
                receive focus.
*/

BOOL CALLBACK __export VideoSelectProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
        static ULNG ulVideoType = 0L;
        static BOOL bLSyncLowToHigh = FALSE;
        static BOOL bFSyncLowToHigh = FALSE;
        HWND hSource = GetDlgItem(hDlg, IDC_CB_CSYNC_SOURCE);
        HWND hThresh = GetDlgItem(hDlg, IDC_CB_CSYNC_THRESH);
        HWND hLSync = GetDlgItem(hDlg, IDC_CK_LSYNC_LO_TO_HI);
        HWND hFSync = GetDlgItem(hDlg, IDC_CK_FSYNC_LO_TO_HI);



    /* What's the message? */

        switch (message)
          {
           case WM_INITDIALOG:
                {
                    ULNG ulVideoTypes = 0L, ulCurVarscanFlags = 0L;
                    ULNG ulCurVideoType = OLC_FG_VID_COMPOSITE;

                    /* Center the dialog box */

                    CenterWindow(hDlg, GetWindow(hDlg, GW_OWNER));

                    /* Enable the radio buttons for the supported video types */

                    (void) OlFgQueryInputCaps(CurDevInfo.DevId,
                                                OLC_FG_IC_VIDEO_TYPE_LIMITS,
                                                &ulVideoTypes,
                                                sizeof(ULNG));

                    EnableWindow(GetDlgItem(hDlg, IDC_RB_COMPOSITE),
                                (BOOL)(ulVideoTypes & OLC_FG_VID_COMPOSITE));

                    EnableWindow(GetDlgItem(hDlg, IDC_RB_VARSCAN),
                                (BOOL)(ulVideoTypes & OLC_FG_VID_VARSCAN));

                    /* If composite is supported, initialize the combo boxes */

                    if ( (USHRT) ulVideoTypes & OLC_FG_VID_COMPOSITE )
                      {
                          InitComboBoxFromControlList(hThresh,
                                                OLC_FG_IC_CSYNC_THRESH_LIST_LIMITS,
                                                OLC_FG_IC_CSYNC_THRESH_LIST);

                          InitCSyncSourceList(hSource);
                      }


                    /* If variable scan is supported, determine the current flag settings */

                    if ( (USHRT) ulVideoTypes & OLC_FG_VID_VARSCAN )
                      {

                         /* Get the current variable scan flag settings */

                         (void) OlFgQueryInputControlValue(CurDevInfo.DevId,
                                                        CurDevInfo.InputSource,
                                                        OLC_FG_CTL_VARSCAN_FLAGS,
                                                        &ulCurVarscanFlags);

                         bLSyncLowToHigh = (BOOL) (ulCurVarscanFlags & OLC_FG_VS_LINE_ON_LO_TO_HI);
                         bFSyncLowToHigh = (BOOL) (ulCurVarscanFlags & OLC_FG_VS_FIELD_ON_LO_TO_HI);
                         Button_SetCheck(hLSync, bLSyncLowToHigh);
                         Button_SetCheck(hFSync, bFSyncLowToHigh);
                      }


                    /* Get the current video type */
                    (void) OlFgQueryInputControlValue(CurDevInfo.DevId,
                                                        CurDevInfo.InputSource,
                                                        OLC_FG_CTL_VIDEO_TYPE,
                                                        &ulCurVideoType);

                    /* Initialize the radio buttons and enable/disable correct controls */

                    EnableWindow(hThresh, FALSE);
                    EnableWindow(hSource, FALSE);
                    EnableWindow(hLSync, FALSE);
                    EnableWindow(hFSync, FALSE);

                    switch ( (USHRT)ulCurVideoType )
                      {
                        case OLC_FG_VID_COMPOSITE:
                           CheckRadioButton(hDlg, IDC_RB_COMPOSITE, IDC_RB_VARSCAN, IDC_RB_COMPOSITE);
                           EnableWindow(hThresh, TRUE);
                           EnableWindow(hSource, TRUE);
                           ulVideoType = OLC_FG_VID_COMPOSITE;
                           break;

                        case OLC_FG_VID_VARSCAN:
                           CheckRadioButton(hDlg, IDC_RB_COMPOSITE, IDC_RB_VARSCAN, IDC_RB_VARSCAN);
                           EnableWindow(hLSync, TRUE);
                           EnableWindow(hFSync, TRUE);
                           ulVideoType = OLC_FG_VID_VARSCAN;
                           break;


                        default:

                        /* Unknown video type - could only happen if more video */
                        /*   types are added to DT-Open Layers                  */

                        break;
                      }

                    return (TRUE);
                        }

           /* message: received a command */

           case WM_COMMAND:
                switch (wParam)
                  {
                   case IDC_RB_COMPOSITE:
                        EnableWindow(hLSync, FALSE);
                        EnableWindow(hFSync, FALSE);
                        EnableWindow(hThresh, TRUE);
                        EnableWindow(hSource, TRUE);
                        ulVideoType = OLC_FG_VID_COMPOSITE;
                        return TRUE;

                        case IDC_RB_VARSCAN:
                        EnableWindow(hThresh, FALSE);
                        EnableWindow(hSource, FALSE);
                        EnableWindow(hLSync, TRUE);
                        EnableWindow(hFSync, TRUE);
                        ulVideoType = OLC_FG_VID_VARSCAN;
                        return TRUE;

                   case IDC_CK_LSYNC_LO_TO_HI:
                        bLSyncLowToHigh = !bLSyncLowToHigh;
                        return TRUE;

                   case IDC_CK_FSYNC_LO_TO_HI:
                        bFSyncLowToHigh = !bFSyncLowToHigh;
                        return TRUE;

                   case IDOK:
                        {
                            OLT_APISTATUS Status = OLC_STS_NORMAL;
                            ULNG ulOldData = 0L;

                            /* Set the video type */

                            Status = OlFgSetInputControlValue(CurDevInfo.DevId,
                                                        CurDevInfo.InputSource,
                                                        OLC_FG_CTL_VIDEO_TYPE,
                                                        ulVideoType,
                                                        &ulOldData);

                            if ( !OlImgIsOkay(Status) )
                               PrintStatus(hDlg, Status, "Unable to set video type.", "Video Type Error");


                            /* Set the input controls for the correct video type */

                            switch ( (USHRT)ulVideoType )
                              {
                                case OLC_FG_VID_COMPOSITE:
                                   SetCsyncInfo(hDlg);
                                   break;

                                case OLC_FG_VID_VARSCAN:
                                   SetVarscanInfo(bLSyncLowToHigh, bFSyncLowToHigh);
                                   break;

                                default:

                                   /* Unknown video type - could only happen if more video */
                                   /*   types are added to DT-Open Layers                  */
                                   break;
                              }

                        }

                        EndDialog(hDlg, TRUE);
                        return (TRUE);

                   case IDCANCEL:
                        EndDialog(hDlg, FALSE);
                        return (TRUE);
                  }
                break;

          }  /* end of switch(message) */


    /* Didn't process the message */

        return (FALSE);
}

/**************************************************************************/
/**************************************************************************/

/*      Function:       InitComboBoxFromControlList

        Description:
                This function initializes the specified combobox with the
                list generated by using the specified queries.  List-type
                capability queries are always done in pairs.  The first
                query returns the number of items in the list.  The second
                query fills in the list itself.


        Input Arguments:
                HWND hDlg                               handle of owning dialog
                HWND hComboBox                          handle of the combo box
                OLT_FG_INPUT_CAP_KEY ListLimitsKey      key for list limts
                OLT_FG_INPUT_CAP_KEY ListKey            key for list itself

        Output Arguments:
                None

        Return Value (void):
                None.
*/

void PRIVATE InitComboBoxFromControlList(HWND hComboBox, OLT_FG_INPUT_CAP_KEY
                                 ListLimitsKey, OLT_FG_INPUT_CAP_KEY ListKey)
{
        OLT_LIST_LIMITS Limits = {0};
        OLT_APISTATUS Status = OLC_STS_NORMAL;
        HGLOBAL hList = NULL;
        LPULNG lpList = NULL;
        int iNominal = 0;
        int i = 0;


    /* How many items in the list? */

        if ( (Status = OlFgQueryInputCaps(CurDevInfo.DevId,
                                        ListLimitsKey,
                                        &Limits,
                                        sizeof(OLT_LIST_LIMITS))) != OLC_STS_NORMAL )
          {
              char msg[128];
              wsprintf(msg, "Unable to get list limits for requested control (status = %#08lx).", Status);
              MessageBox(NULL, msg, NULL, MB_ICONSTOP | MB_OK);
              return;
           }

        /* Allocate space for the list */

        hList = GlobalAlloc(GHND, Limits.Count * sizeof(ULNG));
        if ( !hList )
          {
              char msg[128];
              wsprintf(msg, "%s %s",
                       "Unable to allocate memory for list of possible control values;",
                       "GlobalAlloc failed.");
              MessageBox(NULL, msg, NULL, MB_ICONSTOP | MB_OK);
              return;
          }

        lpList = (LPULNG) GlobalLock(hList);
        if ( !lpList )
          {
              char msg[128];
              GlobalFree(hList);
              wsprintf(msg, "Unable to lock memory for list of possible control values; GlobalLock failed.");
              MessageBox(NULL, msg, NULL, MB_ICONSTOP | MB_OK);
              return;
          }

        /* Fill in the list */

        if ( (Status = OlFgQueryInputCaps(CurDevInfo.DevId,
                                                ListKey,
                                                lpList,
                                                (Limits.Count * sizeof(ULNG)))) != OLC_STS_NORMAL )
          {
              char msg[128];
              GlobalUnlock(hList);
              GlobalFree(hList);
              wsprintf(msg, "Unable to fill in list of possible control values (status = %#08lx).", Status);
              MessageBox(NULL, msg, NULL, MB_ICONSTOP | MB_OK);
              return;
          }

        /* Add the values to the list box */

        for (i = 0; i < (int)Limits.Count; i++)
          {
              char szValue[20];
              wsprintf(szValue, "%ld", lpList[i]);
              ComboBox_AddString(hComboBox, (LPSTR)szValue);
              if (lpList[i] == (ULNG)Limits.Nominal)
                 iNominal = i;
          }

        /* Select the nominal value */

        ComboBox_SetCurSel(hComboBox, iNominal);

        /* Free the memory */

        GlobalUnlock(hList);
        GlobalFree(hList);

        return;
}


/**************************************************************************/
/**************************************************************************/

/*      Function:       InitCSyncSourceList

        Description:
                This function initializes the specified combobox with strings
                representing the possible choices for composite sync sources.
                This combo box does not have the SORT attribute.  We will always
                add the possible sync sources in a specific order so that we can
                easily figure out which one we want.  That order is:

                        1. Use current source (if supported)
                        2. Use external line (if supported)
                        3. Use input 0 (if OLC_FG_CSYNC_SPECIFIC_SRC supported)
                                .
                                .
                                .
                           Use input n-1


        Input Arguments:
                HWND hDlg                               handle of owning dialog
                HWND hComboBox                          handle of the combo box

        Output Arguments:
                None

        Return Value (void):
                None.
*/

void PRIVATE InitCSyncSourceList(HWND hComboBox)
{
        OLT_APISTATUS Status = OLC_STS_NORMAL;
        USHRT usFlags = 0, usSource = 0L;
        ULNG ulData = 0L;
        int iIndex = 0;
        BOOL bSupportsCurrent = FALSE, bSupportsExternal = FALSE;
        ULNG ulSources = 0L;
        int i = 0;

    /* How many items in the list?  */

        if ( (Status = OlFgQueryInputCaps(CurDevInfo.DevId,
                                                OLC_FG_IC_CSYNC_SOURCE_LIMITS,
                                                &ulSources,
                                                sizeof(ULNG))) != OLC_STS_NORMAL )
          {
              char msg[128];
              wsprintf(msg, "Unable to get possible composite sync sources (status = %#08lx).", Status);
              MessageBox(NULL, msg, NULL, MB_ICONSTOP | MB_OK);
              return;
          }

        /* Add the strings to the list box */

        if ( ulSources & OLC_FG_CSYNC_CURRENT_SRC )
          {
              ComboBox_AddString(hComboBox, lpcszCsyncCurrent);
              bSupportsCurrent = TRUE;
          }

        if ( ulSources & OLC_FG_CSYNC_EXTERNAL_LINE )
          {
              ComboBox_AddString(hComboBox, lpcszCsyncExternal);
              bSupportsExternal = TRUE;
          }

        if ( ulSources & OLC_FG_CSYNC_SPECIFIC_SRC )
          {

              /* How many input sources do we support */

              ULNG ulCount = 1L;
              (void) OlFgQueryInputCaps(CurDevInfo.DevId,
                                        OLC_FG_IC_INPUT_SOURCE_COUNT,
                                        &ulCount,
                                        sizeof(ULNG));

              for (i = 0; i < (int)ulCount; i++)
                {
                    char szValue[32];
                    wsprintf(szValue, "%s%d", lpcszCsyncSpecific, i);
                    ComboBox_AddString(hComboBox, (LPSTR)szValue);
                }
          }


    /* Select the current setting */

        /* Get the current composite sync source */

        (void) OlFgQueryInputControlValue(CurDevInfo.DevId,
                                                CurDevInfo.InputSource,
                                                OLC_FG_CTL_CSYNC_SOURCE,
                                                &ulData);

        /* The low 16 bits contains the composite sync source flag */

        switch ( LOWORD(ulData) )
          {
           default:

                /* If the above failed, we'll just select the first thing in list */

           /* Index represents the index into the Comboox drop down list.
              The number of elements in the drop down box depends on the
              types of sync sources supported by the device.  This was determined
              by the previous queries. */

           case OLC_FG_CSYNC_CURRENT_SRC:
                iIndex = 0;
                break;

           /*  If the device can take sync off the current input source, which was stored from
               an earlier query in bSupportsCurrent, then increment iIndex to
               the next item in the drop down box since external line would be the 2nd
               item in the list. If the device cannot take sync off the current line,
               then do not increment iIndex since external line would be the first item in
               the list */

           case OLC_FG_CSYNC_EXTERNAL_LINE:
                iIndex = bSupportsCurrent ? iIndex++ : iIndex;
                break;

           /*  If the device can take sync off the current input source and/or an
               external line, which was stored from earlier queries in bSupportsCurrent
               and bSupportsExternal, then increment iIndex accordingly to
               reflect the position in the list of the first specific source. */

           case OLC_FG_CSYNC_SPECIFIC_SRC:
                iIndex = bSupportsCurrent ? iIndex++ : iIndex;
                iIndex = bSupportsExternal ? iIndex++ : iIndex;

                /* The high 16 bits contains the input source being used */

                iIndex += HIWORD(ulData);
                break;
          }

        ComboBox_SetCurSel(hComboBox, iIndex);

        return;
}

/**************************************************************************/
/**************************************************************************/

/*      Function:       SetCsyncInfo

        Description:
                This function sets the DT-Open Layers composite sync input
                controls according to the control settings of the dialog.


        Input Arguments:
                HWND hDlg                               handle of owning dialog

        Output Arguments:
                None

        Return Value (void):
                None.
*/

void PRIVATE SetCsyncInfo(HWND hDlg)
{
        OLT_APISTATUS Status = OLC_STS_NORMAL;
        ULNG ulOldData = 0L;
        HWND hSource = GetDlgItem(hDlg, IDC_CB_CSYNC_SOURCE);
        HWND hThresh = GetDlgItem(hDlg, IDC_CB_CSYNC_THRESH);
        char szSelection[40];
        int iThresh = 0;
        ULNG ulSource = 0;
        int i = 0;
        int iCount = 0;


    /* Set the Sync threshhold */

        ComboBox_GetText(hThresh, (LPSTR) szSelection, 40);
        iThresh = atoi( (LPSTR) szSelection );
        Status = OlFgSetInputControlValue(CurDevInfo.DevId,
                                                CurDevInfo.InputSource,
                                                OLC_FG_CTL_CSYNC_THRESH,
                                                (ULNG)iThresh,
                                                &ulOldData);

        if ( !OlImgIsOkay(Status) )
           PrintStatus(hDlg, Status, "Unable to set composite sync threshold.", "Input Setup Error");


    /* Set the Sync source */

        ComboBox_GetText(hSource, (LPSTR) szSelection, 40);
        if ( lstrcmp(szSelection, lpcszCsyncExternal) == 0 )
           ulSource = MAKELONG(OLC_FG_CSYNC_EXTERNAL_LINE, 0);
        else
           if ( lstrcmp(szSelection, lpcszCsyncCurrent) == 0 )
              ulSource = MAKELONG(OLC_FG_CSYNC_CURRENT_SRC, 0);
           else
             {
                 /* Assume that user wants a specific input source and figure out which */
                 iCount = ComboBox_GetCount(hSource);
                 for (i = 0; i < iCount; i++)
                   {
                      char szEntry[20];
                      wsprintf(szEntry, "%s%d", lpcszCsyncSpecific, i);
                      if ( lstrcmp(szSelection, szEntry) == 0 )
                      break;
                   }
                 assert(i != iCount);           /* Should always find one or something is wrong */
                 ulSource = MAKELONG(OLC_FG_CSYNC_SPECIFIC_SRC, i);
             }

        /* Set the source */

        Status = OlFgSetInputControlValue(CurDevInfo.DevId,
                                                CurDevInfo.InputSource,
                                                OLC_FG_CTL_CSYNC_SOURCE,
                                                ulSource,
                                                &ulOldData);

        if ( !OlImgIsOkay(Status) )
           PrintStatus(hDlg, Status, "Unable to set composity sync threshold.", "Input Setup Error");

}


/**************************************************************************/
/**************************************************************************/

/*      Function:       SetVarscanInfo

        Description:
                This function sets the DT-Open Layers variable scan input
                controls as indicated.


        Input Arguments:
                BOOL bLSyncLowToHigh                    TRUE if lo-to-hi transition (rising
                                                           edge) on Line Sync line is
                                                           considered to be start of sync
                BOOL bFSyncLowToHigh                    TRUE if lo-to-hi transition (rising
                                                           edge) on Field Sync line is
                                                           considered to be start of sync

        Output Arguments:
                None

        Return Value (void):
                None.
*/

void PRIVATE SetVarscanInfo(BOOL bLSyncLowToHigh, BOOL bFSyncLowToHigh)
{
        OLT_APISTATUS Status = OLC_STS_NORMAL;
        ULNG ulOldData = 0L;
        ULNG ulFlags = 0L;


    /* Set the variable scan flags */

        if (bLSyncLowToHigh)
           ulFlags |= OLC_FG_VS_LINE_ON_LO_TO_HI;
        if (bFSyncLowToHigh)
           ulFlags |= OLC_FG_VS_FIELD_ON_LO_TO_HI;

        Status = OlFgSetInputControlValue(CurDevInfo.DevId,
                                                CurDevInfo.InputSource,
                                                OLC_FG_CTL_VARSCAN_FLAGS,
                                                ulFlags,
                                                &ulOldData);

        if ( !OlImgIsOkay(Status) )
           PrintStatus(NULL, Status, "Unable to set varaible scan flags.", "Input Setup Error");

}


